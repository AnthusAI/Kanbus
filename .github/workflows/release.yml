name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:
    inputs:
      pypi_only:
        description: "Run only the PyPI release job"
        required: false
        type: boolean
        default: true
      rust_only:
        description: "Publish Rust crate and binaries for an existing tag (skip PyPI)"
        required: false
        type: string
        default: ""

permissions:
  contents: write

jobs:
  pypi-release:
    name: PyPI Release
    if: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main') || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.release_tag.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install release tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install python-semantic-release build twine

      - name: Create release tag
        working-directory: python
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PYPI_TOKEN: ${{ secrets.PYPI_TOKEN }}
        run: semantic-release version

      - name: Check release artifacts
        id: release_ready
        working-directory: python
        run: |
          if [ -d "dist" ] && [ -n "$(ls -A dist 2>/dev/null)" ]; then
            echo "release_ready=true" >> "$GITHUB_OUTPUT"
          else
            echo "release_ready=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Publish release to GitHub
        working-directory: python
        if: ${{ steps.release_ready.outputs.release_ready == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PYPI_TOKEN: ${{ secrets.PYPI_TOKEN }}
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: semantic-release publish

      - name: Publish release to PyPI
        working-directory: python
        if: ${{ steps.release_ready.outputs.release_ready == 'true' }}
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: |
          ls -la dist
          twine upload dist/*

      - name: Verify PyPI release
        working-directory: python
        if: ${{ steps.release_ready.outputs.release_ready == 'true' }}
        run: |
          python - <<'PY'
          import json
          import time
          import urllib.request
          import tomllib

          with open("pyproject.toml", "rb") as handle:
              version = tomllib.load(handle)["project"]["version"]

          url = "https://pypi.org/pypi/kanbus/json"
          deadline = time.time() + 120
          while True:
              with urllib.request.urlopen(url, timeout=10) as response:
                  payload = json.load(response)
              releases = payload.get("releases", {})
              if version in releases:
                  print(f"PyPI now shows kanbus {version}.")
                  break
              if time.time() >= deadline:
                  raise SystemExit(f"PyPI did not show kanbus {version} within 120s.")
              print(f"Waiting for PyPI to show kanbus {version}...")
              time.sleep(10)
          PY

      - name: Capture release tag
        id: release_tag
        run: |
          if [ -n "${{ github.event.inputs.rust_only }}" ]; then
            echo "tag=${{ github.event.inputs.rust_only }}" >> "$GITHUB_OUTPUT"
          elif [ "${{ steps.release_ready.outputs.release_ready }}" = "true" ]; then
            git fetch --tags
            tag=$(git describe --tags --abbrev=0 2>/dev/null || true)
            echo "tag=${tag}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=" >> "$GITHUB_OUTPUT"
          fi

  rust-binaries:
    needs: pypi-release
    if: ${{ needs.pypi-release.outputs.release_tag != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.pypi_only != 'true') }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            binary: kbs
            archive: tar.gz
          - os: macos-14
            target: aarch64-apple-darwin
            binary: kbs
            archive: tar.gz
          - os: macos-14
            target: x86_64-apple-darwin
            binary: kbs
            archive: tar.gz
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            binary: kbs.exe
            archive: zip
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Build binary
        run: |
          cd rust
          cargo build --release --target ${{ matrix.target }} --bin kbs

      - name: Package binary (tar.gz)
        if: ${{ matrix.archive == 'tar.gz' }}
        run: |
          mkdir -p dist
          cp rust/target/${{ matrix.target }}/release/${{ matrix.binary }} dist/kbs
          tar -czf dist/kbs-${{ matrix.target }}.tar.gz -C dist kbs

      - name: Package binary (zip)
        if: ${{ matrix.archive == 'zip' && matrix.os != 'windows-latest' }}
        run: |
          mkdir -p dist
          cp rust/target/${{ matrix.target }}/release/${{ matrix.binary }} dist/kbs.exe
          cd dist
          zip kbs-${{ matrix.target }}.zip kbs.exe

      - name: Package binary (zip, windows)
        if: ${{ matrix.archive == 'zip' && matrix.os == 'windows-latest' }}
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          Copy-Item "rust/target/${{ matrix.target }}/release/${{ matrix.binary }}" "dist/kbs.exe"
          Compress-Archive -Path "dist/kbs.exe" -DestinationPath "dist/kbs-${{ matrix.target }}.zip" -Force

      - name: Upload release assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.pypi-release.outputs.release_tag }}
          files: |
            dist/kbs-${{ matrix.target }}.${{ matrix.archive }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  console-server-binaries:
    needs: pypi-release
    if: ${{ needs.pypi-release.outputs.release_tag != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.pypi_only != 'true') }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            binary: kbsc
            archive: tar.gz
            vscode-target: linux-x64
          - os: macos-14
            target: aarch64-apple-darwin
            binary: kbsc
            archive: tar.gz
            vscode-target: darwin-arm64
          - os: macos-14
            target: x86_64-apple-darwin
            binary: kbsc
            archive: tar.gz
            vscode-target: darwin-x64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            binary: kbsc.exe
            archive: zip
            vscode-target: win32-x64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build shared UI package
        run: |
          cd packages/ui
          npm ci --prefer-offline --no-audit
          npm run build

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/console/package-lock.json

      - name: Build frontend assets
        run: |
          cd apps/console
          npm ci --prefer-offline --no-audit
          npm run build

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Build console server
        run: |
          cd rust
          cargo build --release --target ${{ matrix.target }} --bin kbsc --features embed-assets

      - name: Package console server (tar.gz)
        if: ${{ matrix.archive == 'tar.gz' }}
        run: |
          mkdir -p dist
          cp rust/target/${{ matrix.target }}/release/${{ matrix.binary }} dist/kbsc
          tar -czf dist/kbsc-${{ matrix.target }}.tar.gz -C dist kbsc

      - name: Package console server (zip)
        if: ${{ matrix.archive == 'zip' && matrix.os != 'windows-latest' }}
        run: |
          mkdir -p dist
          cp rust/target/${{ matrix.target }}/release/${{ matrix.binary }} dist/kbsc.exe
          cd dist
          zip kbsc-${{ matrix.target }}.zip kbsc.exe

      - name: Package console server (zip, windows)
        if: ${{ matrix.archive == 'zip' && matrix.os == 'windows-latest' }}
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          Copy-Item "rust/target/${{ matrix.target }}/release/${{ matrix.binary }}" "dist/kbsc.exe"
          Compress-Archive -Path "dist/kbsc.exe" -DestinationPath "dist/kbsc-${{ matrix.target }}.zip" -Force

      - name: Upload kbsc artifact for VSCode extension
        uses: actions/upload-artifact@v4
        with:
          name: kbsc-${{ matrix.vscode-target }}
          path: rust/target/${{ matrix.target }}/release/${{ matrix.binary }}

      - name: Upload console server assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.pypi-release.outputs.release_tag }}
          files: |
            dist/kbsc-${{ matrix.target }}.${{ matrix.archive }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  vscode-extension:
    name: Publish VSCode Extension
    needs: [pypi-release, console-server-binaries]
    if: ${{ needs.pypi-release.outputs.release_tag != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.pypi_only != 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/vscode/package-lock.json

      - name: Install extension dependencies
        run: npm ci
        working-directory: apps/vscode

      - name: Compile TypeScript
        run: npm run compile
        working-directory: apps/vscode

      - name: Download all kbsc binaries
        uses: actions/download-artifact@v4
        with:
          path: apps/vscode/artifacts
          pattern: kbsc-*

      - name: Package extension for each platform
        run: |
          for target in darwin-arm64 darwin-x64 linux-x64; do
            mkdir -p bin
            cp artifacts/kbsc-$target/kbsc bin/kbsc
            chmod +x bin/kbsc
            ./node_modules/.bin/vsce package --target $target
          done
          mkdir -p bin
          cp artifacts/kbsc-win32-x64/kbsc.exe bin/kbsc.exe
          ./node_modules/.bin/vsce package --target win32-x64
        working-directory: apps/vscode

      - name: Publish all platform packages
        env:
          VSCE_PAT: ${{ secrets.VSCE_PAT }}
        run: |
          if [ -z "$VSCE_PAT" ]; then
            echo "VSCE_PAT not set; skipping VSCode Marketplace publish."
            exit 0
          fi
          ./node_modules/.bin/vsce publish --packagePath *.vsix
        working-directory: apps/vscode

  rust-crate:
    needs: pypi-release
    if: ${{ needs.pypi-release.outputs.release_tag != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.pypi_only != 'true') }}
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: |
            packages/ui/package-lock.json
            apps/console/package-lock.json

      - name: Build shared UI package
        working-directory: ${{ github.workspace }}/packages/ui
        run: |
          npm ci --prefer-offline --no-audit
          npm run build

      - name: Build console frontend assets
        working-directory: ${{ github.workspace }}/apps/console
        run: |
          npm ci --prefer-offline --no-audit
          npm run build

      - name: Sync console assets into Rust bundle
        run: |
          rm -rf rust/embedded_assets/console
          cp -R apps/console/dist rust/embedded_assets/console

      - name: Verify console assets bundled for crate
        run: |
          test -f rust/embedded_assets/console/index.html
          (cd rust && cargo package --locked --list) | grep -Eq '^embedded_assets/console/index.html$'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo directories
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            rust/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('rust/Cargo.lock') }}

      - name: Sync crate version to release tag
        working-directory: rust
        run: |
          tag_version="${{ needs.pypi-release.outputs.release_tag }}"
          tag_version="${tag_version#v}"
          python - <<'PY' "$tag_version"
          import pathlib, re, sys

          desired = sys.argv[1]
          path = pathlib.Path("Cargo.toml")
          text = path.read_text()

          pattern = r'(?m)^version\s*=\s*"([^"]*)"'
          match = re.search(pattern, text)
          if not match:
              print("version field not found; check Cargo.toml format")
              sys.exit(1)

          current = match.group(1)
          if current == desired:
              print(f"version already {current}; nothing to do")
              sys.exit(0)

          new_text = re.sub(pattern, f'version = \"{desired}\"', text, count=1)
          path.write_text(new_text)
          print(f"version updated {current} -> {desired}")
          PY

      - name: Update Cargo.lock
        working-directory: rust
        run: cargo generate-lockfile

      - name: fmt
        working-directory: rust
        run: cargo fmt --check

      - name: clippy
        working-directory: rust
        run: cargo clippy --locked -- -D warnings

      - name: test
        working-directory: rust
        run: cargo test --locked

      - name: package (verification)
        working-directory: rust
        run: cargo package --locked

      - name: Check if crate version already exists
        id: crate_version_check
        run: |
          version="${{ needs.pypi-release.outputs.release_tag }}"
          version="${version#v}"
          python - <<'PY' "$version"
          import json
          import os
          import sys
          import urllib.request

          version = sys.argv[1]
          url = "https://crates.io/api/v1/crates/kanbus"
          exists = True
          try:
              with urllib.request.urlopen(url, timeout=10) as response:
                  payload = json.load(response)
              versions = payload.get("versions", [])
              exists = any(entry.get("num") == version for entry in versions)
              print(f"crate version {version} exists: {exists}")
          except Exception as exc:
              print(f"skipping publish: could not verify version on crates.io ({exc})")

          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              print("GITHUB_OUTPUT not set; skipping publish")
              sys.exit(0)
          with open(output_path, "a", encoding="utf-8") as handle:
              handle.write(f"publish={'false' if exists else 'true'}\n")
          PY

      - name: publish
        if: ${{ steps.crate_version_check.outputs.publish == 'true' }}
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        working-directory: rust
        run: cargo publish --locked --token "$CARGO_REGISTRY_TOKEN"
